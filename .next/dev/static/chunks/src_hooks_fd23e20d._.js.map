{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useUrlScraper.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport { UseFormSetValue } from 'react-hook-form';\nimport { useMutation } from '@tanstack/react-query';\nimport { fetchUrlContent } from '../services/research/webScraper';\nimport { extractWebsiteTypeAndTerm } from '../services/research/referenceAnalysisService';\nimport { ArticleFormValues } from '../schemas/formSchema';\nimport { CostBreakdown, ScrapedImage, TokenUsage } from '../types';\nimport { dedupeScrapedImages } from '../utils/imageUtils';\n\ninterface UseUrlScraperParams {\n    setValue: UseFormSetValue<ArticleFormValues>;\n    onAddCost?: (cost: CostBreakdown, usage: TokenUsage) => void;\n    setInputType: (type: 'text' | 'url') => void;\n}\n\nexport const useUrlScraper = ({\n    setValue,\n    onAddCost,\n    setInputType,\n}: UseUrlScraperParams) => {\n    const [scrapedImages, setScrapedImages] = useState<ScrapedImage[]>([]);\n    const mutation = useMutation({\n        mutationFn: async (url: string) => {\n            if (!url) throw new Error('URL is required');\n            const { title, content, images } = await fetchUrlContent(url);\n            return { title, content, images };\n        },\n        onSuccess: async ({ title, content, images }) => {\n            setValue('referenceContent', content);\n            setScrapedImages(dedupeScrapedImages(images));\n            if (title) setValue('title', title);\n\n            try {\n                const brandRes = await extractWebsiteTypeAndTerm(content);\n                if (brandRes.data.websiteType) setValue('websiteType', brandRes.data.websiteType);\n                if (brandRes.data.authorityTerms) setValue('authorityTerms', brandRes.data.authorityTerms);\n                if (onAddCost) onAddCost(brandRes.cost, brandRes.usage);\n            } catch (aiError) {\n                console.warn('Failed to auto-extract brand info', aiError);\n            }\n            setInputType('text');\n        },\n        onError: () => {\n            alert('Failed to fetch content from URL. The site might block bots.');\n        }\n    });\n\n    const fetchAndPopulate = useCallback(async (url: string) => {\n        await mutation.mutateAsync(url);\n    }, [mutation]);\n\n    return {\n        scrapedImages,\n        setScrapedImages,\n        isFetchingUrl: mutation.isPending,\n        fetchAndPopulate,\n    };\n};\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AACA;AAGA;;;;;;;AAQO,MAAM,gBAAgB,CAAC,EAC1B,QAAQ,EACR,SAAS,EACT,YAAY,EACM;;IAClB,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAiB,EAAE;IACrE,MAAM,WAAW,IAAA,gMAAW,EAAC;QACzB,UAAU;mDAAE,OAAO;gBACf,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;gBAC1B,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,+JAAe,EAAC;gBACzD,OAAO;oBAAE;oBAAO;oBAAS;gBAAO;YACpC;;QACA,SAAS;mDAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE;gBACxC,SAAS,oBAAoB;gBAC7B,iBAAiB,IAAA,oJAAmB,EAAC;gBACrC,IAAI,OAAO,SAAS,SAAS;gBAE7B,IAAI;oBACA,MAAM,WAAW,MAAM,IAAA,uLAAyB,EAAC;oBACjD,IAAI,SAAS,IAAI,CAAC,WAAW,EAAE,SAAS,eAAe,SAAS,IAAI,CAAC,WAAW;oBAChF,IAAI,SAAS,IAAI,CAAC,cAAc,EAAE,SAAS,kBAAkB,SAAS,IAAI,CAAC,cAAc;oBACzF,IAAI,WAAW,UAAU,SAAS,IAAI,EAAE,SAAS,KAAK;gBAC1D,EAAE,OAAO,SAAS;oBACd,QAAQ,IAAI,CAAC,qCAAqC;gBACtD;gBACA,aAAa;YACjB;;QACA,OAAO;mDAAE;gBACL,MAAM;YACV;;IACJ;IAEA,MAAM,mBAAmB,IAAA,4KAAW;uDAAC,OAAO;YACxC,MAAM,SAAS,WAAW,CAAC;QAC/B;sDAAG;QAAC;KAAS;IAEb,OAAO;QACH;QACA;QACA,eAAe,SAAS,SAAS;QACjC;IACJ;AACJ;GA1Ca;;QAMQ,gMAAW"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useProfileManager.ts"],"sourcesContent":["import { useCallback } from 'react';\nimport { UseFormSetValue } from 'react-hook-form';\nimport { ArticleFormValues } from '../schemas/formSchema';\nimport { SavedProfile } from '../types';\n\ninterface ProfileManagerParams {\n    savedProfiles?: SavedProfile[];\n    setSavedProfiles?: (profiles: SavedProfile[]) => void;\n    activeProfile?: SavedProfile | null;\n    onSetActiveProfile?: (profile: SavedProfile | null) => void;\n    brandKnowledge?: string;\n    setValue: UseFormSetValue<ArticleFormValues>;\n}\n\nexport const useProfileManager = ({\n    savedProfiles = [],\n    setSavedProfiles,\n    activeProfile,\n    onSetActiveProfile,\n    brandKnowledge,\n    setValue,\n}: ProfileManagerParams) => {\n\n    const createProfile = useCallback((name: string, values: ArticleFormValues) => {\n        if (!setSavedProfiles || !name.trim()) return null;\n\n        const newProfile: SavedProfile = {\n            id: Date.now().toString(),\n            name: name.trim(),\n            websiteType: values.websiteType || '',\n            authorityTerms: values.authorityTerms || '',\n            brandKnowledge: brandKnowledge || '',\n            targetAudience: values.targetAudience,\n            useRag: values.useRag,\n            productRawText: values.productRawText\n        };\n\n        const updated = [...savedProfiles, newProfile];\n        setSavedProfiles(updated);\n        onSetActiveProfile?.(newProfile);\n        return newProfile;\n    }, [brandKnowledge, onSetActiveProfile, savedProfiles, setSavedProfiles]);\n\n    const updateProfile = useCallback((values: ArticleFormValues) => {\n        if (!setSavedProfiles || !activeProfile) return null;\n\n        const updatedProfiles = savedProfiles.map(p => p.id === activeProfile.id ? {\n            ...p,\n            websiteType: values.websiteType || '',\n            authorityTerms: values.authorityTerms || '',\n            targetAudience: values.targetAudience,\n            useRag: values.useRag,\n            productRawText: values.productRawText,\n            brandKnowledge: brandKnowledge\n        } : p);\n\n        setSavedProfiles(updatedProfiles);\n        const updatedActive = updatedProfiles.find(p => p.id === activeProfile.id) || null;\n        onSetActiveProfile?.(updatedActive);\n        return updatedActive;\n    }, [activeProfile, brandKnowledge, onSetActiveProfile, savedProfiles, setSavedProfiles]);\n\n    const deleteProfile = useCallback((id: string) => {\n        if (!setSavedProfiles) return;\n        const updatedProfiles = savedProfiles.filter(p => p.id !== id);\n        setSavedProfiles(updatedProfiles);\n        if (activeProfile?.id === id) {\n            onSetActiveProfile?.(null);\n        }\n    }, [activeProfile?.id, onSetActiveProfile, savedProfiles, setSavedProfiles]);\n\n    const applyProfileToForm = useCallback((profile: SavedProfile) => {\n        setValue('websiteType', profile.websiteType);\n        setValue('authorityTerms', profile.authorityTerms);\n        setValue('targetAudience', profile.targetAudience);\n        if (profile.useRag !== undefined) setValue('useRag', profile.useRag);\n\n        if (profile.productRawText) {\n            setValue('productRawText', profile.productRawText);\n        } else if (profile.productBrief) {\n            setValue('productRawText', `${profile.productBrief.productName} - ${profile.productBrief.usp}. Link: ${profile.productBrief.ctaLink}`);\n        }\n\n        onSetActiveProfile?.(profile);\n    }, [onSetActiveProfile, setValue]);\n\n    const loadProductFromProfile = useCallback((profile: SavedProfile) => {\n        if (profile.productRawText) {\n            setValue('productRawText', profile.productRawText);\n        } else if (profile.productBrief) {\n            setValue('productRawText', `${profile.productBrief.productName} - ${profile.productBrief.usp}. Link: ${profile.productBrief.ctaLink}`);\n        } else {\n            alert('This profile has no saved product/service details.');\n        }\n    }, [setValue]);\n\n    return {\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        applyProfileToForm,\n        loadProductFromProfile,\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useStorageReset.ts"],"sourcesContent":["interface ClearOptions {\n    reload?: boolean;\n    includeForm?: boolean;\n}\n\nconst CLEAR_KEYS = [\n    'pro_content_writer_analysis',\n    'pro_content_writer_generation',\n    'ai_writer_editor_autosave_v1'\n];\n\nexport const useStorageReset = () => {\n    const clearAll = ({ reload = true, includeForm = true }: ClearOptions = {}) => {\n        if (typeof window === 'undefined') return;\n        try {\n            const keys = [...CLEAR_KEYS];\n            if (includeForm) keys.push('pro_content_writer_inputs_simple_v4');\n            keys.forEach(k => localStorage.removeItem(k));\n            sessionStorage.removeItem('autosave_restore_decision');\n        } catch (e) {\n            console.warn('Failed to clear storage', e);\n        }\n        if (reload) window.location.reload();\n    };\n\n    return { clearAll };\n};\n"],"names":[],"mappings":";;;;AAKA,MAAM,aAAa;IACf;IACA;IACA;CACH;AAEM,MAAM,kBAAkB;IAC3B,MAAM,WAAW,CAAC,EAAE,SAAS,IAAI,EAAE,cAAc,IAAI,EAAgB,GAAG,CAAC,CAAC;QACtE;;QACA,IAAI;YACA,MAAM,OAAO;mBAAI;aAAW;YAC5B,IAAI,aAAa,KAAK,IAAI,CAAC;YAC3B,KAAK,OAAO,CAAC,CAAA,IAAK,aAAa,UAAU,CAAC;YAC1C,eAAe,UAAU,CAAC;QAC9B,EAAE,OAAO,GAAG;YACR,QAAQ,IAAI,CAAC,2BAA2B;QAC5C;QACA,IAAI,QAAQ,OAAO,QAAQ,CAAC,MAAM;IACtC;IAEA,OAAO;QAAE;IAAS;AACtB"}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useArticleForm.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { articleFormSchema, ArticleFormValues } from '../schemas/formSchema';\nimport { SavedProfile, ScrapedImage } from '../types';\nimport { useUrlScraper } from './useUrlScraper';\nimport { useProfileManager } from './useProfileManager';\nimport { useStorageReset } from './useStorageReset';\nimport { dedupeScrapedImages } from '../utils/imageUtils';\n\nconst STORAGE_KEY = 'pro_content_writer_inputs_simple_v4';\n\ninterface UseArticleFormParams {\n    brandKnowledge?: string;\n    savedProfiles?: SavedProfile[];\n    setSavedProfiles?: (profiles: SavedProfile[]) => void;\n    activeProfile?: SavedProfile | null;\n    onSetActiveProfile?: (profile: SavedProfile | null) => void;\n    setInputType: (type: 'text' | 'url') => void;\n}\n\nexport const useArticleForm = ({\n    brandKnowledge = '',\n    savedProfiles = [],\n    setSavedProfiles,\n    activeProfile,\n    onSetActiveProfile,\n    setInputType,\n}: UseArticleFormParams) => {\n    const {\n        register,\n        handleSubmit,\n        setValue,\n        watch,\n        reset,\n        formState: { errors }\n    } = useForm<ArticleFormValues>({\n        resolver: zodResolver(articleFormSchema),\n        defaultValues: {\n            title: '',\n            referenceContent: '',\n            sampleOutline: '',\n            authorityTerms: '',\n            websiteType: '',\n            targetAudience: 'zh-TW',\n            useRag: false,\n            autoImagePlan: false,\n            productRawText: '',\n            urlInput: '',\n            productUrlList: ''\n        }\n    });\n\n    const watchedValues = watch();\n\n    const [productMode, setProductMode] = useState<'text' | 'url'>('text');\n    const [isSummarizingProduct, setIsSummarizingProduct] = useState(false);\n    const [refCharCount, setRefCharCount] = useState(0);\n    const [refWordCount, setRefWordCount] = useState(0);\n    const { clearAll } = useStorageReset();\n\n    const {\n        scrapedImages,\n        setScrapedImages,\n        isFetchingUrl,\n        fetchAndPopulate\n    } = useUrlScraper({\n        setValue,\n        setInputType,\n    });\n\n    const {\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        applyProfileToForm,\n        loadProductFromProfile,\n    } = useProfileManager({\n        savedProfiles,\n        setSavedProfiles,\n        activeProfile,\n        onSetActiveProfile,\n        brandKnowledge,\n        setValue,\n    });\n\n    // Restore persisted form\n    useEffect(() => {\n        if (typeof window === 'undefined') return;\n        const saved = localStorage.getItem(STORAGE_KEY);\n        if (saved) {\n            try {\n                const parsed = JSON.parse(saved);\n                Object.keys(parsed).forEach(key => {\n                    // @ts-ignore\n                    setValue(key, parsed[key]);\n                });\n                if (parsed.scrapedImages) setScrapedImages(dedupeScrapedImages(parsed.scrapedImages));\n            } catch (e) {\n                console.warn('Failed to restore persisted form', e);\n            }\n        }\n    }, [setScrapedImages, setValue]);\n\n    // Persist + counts\n    useEffect(() => {\n        const subscription = watch((values) => {\n            const dataToSave = { ...values, scrapedImages };\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));\n\n            const content = values.referenceContent || '';\n            setRefCharCount(content.length);\n            const cjkCount = (content.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n            const nonCjkText = content.replace(/[\\u4e00-\\u9fa5]/g, ' ');\n            const englishWords = nonCjkText.trim().split(/\\s+/).filter(w => w.length > 0);\n            setRefWordCount(cjkCount + englishWords.length);\n        });\n        return () => subscription.unsubscribe();\n    }, [scrapedImages, watch]);\n\n    // Apply active profile\n    useEffect(() => {\n        if (activeProfile) {\n            applyProfileToForm(activeProfile);\n        }\n    }, [activeProfile, applyProfileToForm]);\n\n    const usableImages = useMemo(() => scrapedImages.filter(img => !img.ignored), [scrapedImages]);\n\n    const handleClear = useCallback(() => {\n        if (typeof window === 'undefined') return;\n        if (!confirm('確定要清空所有輸入與紀錄嗎？\\n這會重置表單、分析與草稿，並重新整理頁面。')) return;\n        reset();\n        setScrapedImages([]);\n        setValue('targetAudience', 'zh-TW');\n        clearAll({ reload: true, includeForm: true });\n    }, [clearAll, reset, setScrapedImages, setValue]);\n\n    return {\n        register,\n        handleSubmit,\n        setValue,\n        watchedValues,\n        errors,\n        productMode,\n        setProductMode,\n        isSummarizingProduct,\n        setIsSummarizingProduct,\n        refCharCount,\n        refWordCount,\n        scrapedImages,\n        setScrapedImages,\n        isFetchingUrl,\n        fetchAndPopulate,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        applyProfileToForm,\n        loadProductFromProfile,\n        usableImages,\n        handleClear,\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useSemanticFilter.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { embedTexts, cosineSimilarity } from '../services/engine/embeddingService';\n\nconst DEFAULT_SEMANTIC_THRESHOLD = 0.79;\n\nconst splitIntoBlankLineChunks = (content: string): string[] =>\n    content\n        .split(/\\n\\s*\\n+/)\n        .map(chunk => chunk.trim())\n        .filter(Boolean);\n\nexport const useSemanticFilter = () => {\n    const [isChunkModalOpen, setIsChunkModalOpen] = useState(false);\n    const [chunkPreview, setChunkPreview] = useState<string[]>([]);\n    const [isFilteringChunks, setIsFilteringChunks] = useState(false);\n    const [filterError, setFilterError] = useState<string | null>(null);\n    const [chunkScores, setChunkScores] = useState<number[]>([]);\n    const [isScoringChunks, setIsScoringChunks] = useState(false);\n    const [manualKeep, setManualKeep] = useState<Record<number, boolean>>({});\n    const [semanticThreshold, setSemanticThreshold] = useState<number>(DEFAULT_SEMANTIC_THRESHOLD);\n    const [semanticThresholdInput, setSemanticThresholdInput] = useState<string>(DEFAULT_SEMANTIC_THRESHOLD.toString());\n\n    const commitSemanticThreshold = useCallback((raw?: string) => {\n        const candidate = (typeof raw === 'string' ? raw : semanticThresholdInput).trim();\n        if (candidate === '') {\n            setSemanticThresholdInput(semanticThreshold.toString());\n            return semanticThreshold;\n        }\n\n        const parsed = parseFloat(candidate);\n        if (Number.isNaN(parsed)) {\n            setSemanticThresholdInput(semanticThreshold.toString());\n            return semanticThreshold;\n        }\n\n        const clamped = Math.min(1, Math.max(0, parsed));\n        const normalized = Math.round(clamped * 100) / 100;\n        setSemanticThreshold(normalized);\n        setSemanticThresholdInput(normalized.toString());\n        return normalized;\n    }, [semanticThresholdInput, semanticThreshold]);\n\n    const scoreChunks = useCallback(async (chunks: string[], title: string) => {\n        if (!title) {\n            setFilterError('請先填寫標題，再計算語意距離。');\n            return null;\n        }\n\n        setIsScoringChunks(true);\n        setFilterError(null);\n\n        try {\n            const [titleEmbeddings, chunkEmbeddings] = await Promise.all([\n                embedTexts([title]),\n                embedTexts(chunks),\n            ]);\n\n            const titleEmbedding = titleEmbeddings[0];\n            if (!titleEmbedding?.length) {\n                throw new Error('無法取得標題向量，請稍後再試。');\n            }\n\n            const similarities = chunks.map((chunk, idx) => {\n                const chunkEmbedding = chunkEmbeddings[idx];\n                if (!chunkEmbedding?.length) return 1;\n                return cosineSimilarity(titleEmbedding, chunkEmbedding);\n            });\n\n            setChunkScores(similarities);\n            return similarities;\n        } catch (error: any) {\n            setFilterError(error?.message || '語意過濾失敗，請稍後再試。');\n            return null;\n        } finally {\n            setIsScoringChunks(false);\n        }\n    }, []);\n\n    const openFilterModal = useCallback((content: string, title: string) => {\n        const chunks = splitIntoBlankLineChunks(content);\n        if (!chunks.length) {\n            alert('找不到可以分段的內容（需有空白行分隔）。');\n            return;\n        }\n\n        setChunkPreview(chunks);\n        setFilterError(null);\n        setChunkScores([]);\n        setManualKeep({});\n        setIsChunkModalOpen(true);\n        void scoreChunks(chunks, title);\n    }, [scoreChunks]);\n\n    const applyFilter = useCallback(async (content: string, title: string): Promise<string | null> => {\n        const chunks = chunkPreview.length ? chunkPreview : splitIntoBlankLineChunks(content);\n        if (!chunks.length) {\n            setFilterError('找不到可用的段落。');\n            return null;\n        }\n\n        setIsFilteringChunks(true);\n        setFilterError(null);\n\n        try {\n            const existingScores = (chunkScores.length === chunks.length) ? chunkScores : null;\n            const computedScores = existingScores || (await scoreChunks(chunks, title)) || [];\n\n            if (!computedScores.length) {\n                setFilterError('無法取得語意距離，請確認標題與 API 設定。');\n                return null;\n            }\n\n            const keptChunks = chunks.filter((chunk, idx) => {\n                const similarity = computedScores[idx] ?? 1;\n                const forcedKeep = manualKeep[idx];\n                return forcedKeep || similarity >= semanticThreshold;\n            });\n\n            const filteredContent = keptChunks.join('\\n\\n').trim();\n            setIsChunkModalOpen(false);\n            return filteredContent;\n        } catch (error: any) {\n            setFilterError(error?.message || '語意過濾失敗，請稍後再試。');\n            return null;\n        } finally {\n            setIsFilteringChunks(false);\n        }\n    }, [chunkPreview, chunkScores, manualKeep, scoreChunks, semanticThreshold]);\n\n    return {\n        isChunkModalOpen,\n        setIsChunkModalOpen,\n        chunkPreview,\n        chunkScores,\n        isScoringChunks,\n        isFilteringChunks,\n        filterError,\n        manualKeep,\n        setManualKeep,\n        openFilterModal,\n        applyFilter,\n        semanticThreshold,\n        semanticThresholdInput,\n        setSemanticThresholdInput,\n        commitSemanticThreshold,\n        DEFAULT_SEMANTIC_THRESHOLD\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useImageEditor.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport { TargetAudience, CostBreakdown, TokenUsage, ScrapedImage, ImageAssetPlan } from '../types';\nimport { generateImagePromptFromContext, generateImage, planImagesForArticle } from '../services/generation/imageService';\n\ninterface UseImageEditorParams {\n    editorRef: React.RefObject<HTMLDivElement>;\n    tiptapApi?: {\n        insertImage: (src: string, alt?: string) => void;\n        getPlainText?: () => string;\n        getHtml?: () => string;\n        setHtml?: (html: string) => void;\n    };\n    imageContainerRef?: React.RefObject<HTMLElement>;\n    targetAudience: TargetAudience;\n    visualStyle?: string;\n    scrapedImages: ScrapedImage[];\n    onAddCost?: (cost: CostBreakdown, usage: TokenUsage) => void;\n    handleInput: (e: React.FormEvent<HTMLDivElement>) => void;\n    saveSelection: () => Range | null;\n    restoreSelection: () => void;\n}\n\nexport const useImageEditor = ({\n    editorRef,\n    tiptapApi,\n    imageContainerRef,\n    targetAudience,\n    visualStyle,\n    scrapedImages,\n    onAddCost,\n    handleInput,\n    saveSelection,\n    restoreSelection,\n}: UseImageEditorParams) => {\n    const [showImageModal, setShowImageModal] = useState(false);\n    const [imagePrompt, setImagePrompt] = useState('');\n    const [isImageLoading, setIsImageLoading] = useState(false);\n    const [isDownloadingImages, setIsDownloadingImages] = useState(false);\n    const [imagePlans, setImagePlans] = useState<ImageAssetPlan[]>([]);\n    const [isPlanning, setIsPlanning] = useState(false);\n    const [isBatchProcessing, setIsBatchProcessing] = useState(false);\n\n    const openImageModal = useCallback(async () => {\n        saveSelection();\n        setShowImageModal(true);\n        setIsImageLoading(true);\n        setImagePrompt('Analyzing context...');\n\n        let contextText = '';\n        if (tiptapApi?.getPlainText) {\n            const text = tiptapApi.getPlainText();\n            contextText = text.substring(0, 200);\n        } else if (editorRef.current) {\n            const fullText = editorRef.current.innerText;\n            const selection = window.getSelection();\n            if (selection && selection.rangeCount > 0) {\n                const range = selection.getRangeAt(0);\n                const preCaretRange = range.cloneRange();\n                preCaretRange.selectNodeContents(editorRef.current);\n                preCaretRange.setEnd(range.startContainer, range.startOffset);\n                const startOffset = preCaretRange.toString().length;\n                const start = Math.max(0, startOffset - 100);\n                const end = Math.min(fullText.length, startOffset + 100);\n                contextText = fullText.substring(start, end);\n            } else {\n                contextText = fullText.substring(0, 200);\n            }\n        }\n\n        try {\n            const res = await generateImagePromptFromContext(contextText, targetAudience, visualStyle || '');\n            setImagePrompt(res.data);\n            onAddCost?.(res.cost, res.usage);\n        } catch (e) {\n            setImagePrompt('Create a realistic image relevant to this article.');\n        } finally {\n            setIsImageLoading(false);\n        }\n    }, [editorRef, onAddCost, saveSelection, targetAudience, visualStyle]);\n\n    const generateImageFromPrompt = useCallback(async (prompt: string) => {\n        if (!prompt) return;\n        setIsImageLoading(true);\n        try {\n            const res = await generateImage(prompt);\n            if (res.data) {\n                const imgHtml = `<img src=\"${res.data}\" alt=\"${prompt}\" style=\"max-width: 100%; height: auto; border-radius: 8px; margin: 20px 0;\" /><br/>`;\n                if (tiptapApi) {\n                    tiptapApi.insertImage(res.data, prompt);\n                } else {\n                    restoreSelection();\n                    document.execCommand('insertHTML', false, imgHtml);\n                    if (editorRef.current) handleInput({ currentTarget: editorRef.current } as React.FormEvent<HTMLDivElement>);\n                }\n                onAddCost?.(res.cost, res.usage);\n                setShowImageModal(false);\n            } else {\n                alert('Image generation returned no data.');\n            }\n        } catch (e) {\n            console.error('Image generation error', e);\n            alert('Failed to generate image.');\n        } finally {\n            setIsImageLoading(false);\n        }\n    }, [editorRef, handleInput, onAddCost, restoreSelection]);\n\n    const downloadImages = useCallback(async () => {\n        const container = imageContainerRef?.current || editorRef.current || document.body;\n        const images = container.querySelectorAll('img');\n        if (images.length === 0) {\n            alert('No images found in the editor to download.');\n            return;\n        }\n        if (!confirm(`Found ${images.length} images in the article. Download them now?`)) return;\n\n        setIsDownloadingImages(true);\n        const downloadLink = document.createElement('a');\n        downloadLink.style.display = 'none';\n        document.body.appendChild(downloadLink);\n\n        try {\n            for (let i = 0; i < images.length; i++) {\n                const img = images[i] as HTMLImageElement;\n                const src = img.src;\n                const ext = src.includes('image/jpeg') ? 'jpg' : 'png';\n                const filename = `article-image-${Date.now()}-${i + 1}.${ext}`;\n\n                if (src.startsWith('data:')) {\n                    downloadLink.href = src;\n                    downloadLink.download = filename;\n                    downloadLink.click();\n                } else {\n                    try {\n                        const response = await fetch(src);\n                        const blob = await response.blob();\n                        const url = URL.createObjectURL(blob);\n                        downloadLink.href = url;\n                        downloadLink.download = filename;\n                        downloadLink.click();\n                        URL.revokeObjectURL(url);\n                    } catch (err) {\n                        console.warn(`Failed to download ${src}, opening in new tab instead.`);\n                        window.open(src, '_blank');\n                    }\n                }\n                await new Promise((r) => setTimeout(r, 200));\n            }\n        } catch (e) {\n            console.error('Download failed', e);\n            alert('Some images could not be downloaded.');\n        } finally {\n            document.body.removeChild(downloadLink);\n            setIsDownloadingImages(false);\n        }\n    }, [editorRef]);\n\n    const updatePlanPrompt = useCallback((id: string, newPrompt: string) => {\n        setImagePlans((prev) => prev.map((p) => (p.id === id ? { ...p, generatedPrompt: newPrompt } : p)));\n    }, []);\n\n    const injectImageIntoEditor = useCallback((plan: ImageAssetPlan, method: 'auto' | 'cursor' = 'auto') => {\n        if (!plan.url) return;\n\n        const imgHtml = `<img src=\"${plan.url}\" alt=\"${plan.generatedPrompt}\" style=\"max-width: 100%; height: auto; border-radius: 8px; margin: 24px 0; display: block; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\" />`;\n        const anchorText = plan.insertAfter?.trim() || '';\n        const tryInjectByAnchor = (html: string, replaceFn: (nextHtml: string) => void) => {\n            const insertAt = (target: string) => {\n                if (!target || !html.includes(target)) return false;\n                replaceFn(html.replace(target, `${target}<br/>${imgHtml}`));\n                return true;\n            };\n\n            if (insertAt(anchorText)) return true;\n\n            const chunks = anchorText\n                .split(/[，,。.\\n\\t\\s、：:]+/)\n                .filter((c) => c.length >= 4)\n                .sort((a, b) => b.length - a.length);\n\n            for (const chunk of chunks) {\n                if (insertAt(chunk)) return true;\n            }\n            return false;\n        };\n\n        if (tiptapApi) {\n            const insertAtSelection = () => tiptapApi.insertImage(plan.url!, plan.generatedPrompt);\n\n            if (method === 'cursor' || !anchorText || !tiptapApi.getHtml || !tiptapApi.setHtml) {\n                insertAtSelection();\n                return;\n            }\n\n            const html = tiptapApi.getHtml();\n            const injected = tryInjectByAnchor(html, (nextHtml) => tiptapApi.setHtml!(nextHtml));\n            if (!injected) {\n                insertAtSelection();\n            }\n            return;\n        }\n\n        if (!editorRef.current) return;\n\n        if (method === 'cursor') {\n            restoreSelection();\n            document.execCommand('insertHTML', false, imgHtml);\n            handleInput({ currentTarget: editorRef.current } as React.FormEvent<HTMLDivElement>);\n            return;\n        }\n\n        const currentHtml = editorRef.current.innerHTML;\n        const injected = tryInjectByAnchor(currentHtml, (nextHtml) => {\n            editorRef.current!.innerHTML = nextHtml;\n            handleInput({ currentTarget: editorRef.current! } as React.FormEvent<HTMLDivElement>);\n        });\n\n        if (!injected) {\n            alert(`Could not find anchor: \"...${anchorText.substring(0, 15)}...\". \\n\\nPlease place your cursor in the text and click the \"Cursor\" button to insert manually.`);\n        }\n    }, [editorRef, handleInput, restoreSelection, tiptapApi]);\n\n    const generateSinglePlan = useCallback(async (plan: ImageAssetPlan) => {\n        if (plan.status === 'generating') return;\n        setImagePlans((prev) => prev.map((p) => (p.id === plan.id ? { ...p, status: 'generating' } : p)));\n        try {\n            const imgRes = await generateImage(plan.generatedPrompt);\n            if (imgRes.data) {\n                const updatedPlan = { ...plan, status: 'done' as const, url: imgRes.data || undefined };\n                setImagePlans((prev) => prev.map((p) => (p.id === plan.id ? updatedPlan : p)));\n                onAddCost?.(imgRes.cost, imgRes.usage);\n            } else {\n                setImagePlans((prev) => prev.map((p) => (p.id === plan.id ? { ...p, status: 'error' } : p)));\n            }\n        } catch (e) {\n            console.error('Single generation failed', e);\n            setImagePlans((prev) => prev.map((p) => (p.id === plan.id ? { ...p, status: 'error' } : p)));\n        }\n    }, [onAddCost]);\n\n    const handleBatchProcess = useCallback(async () => {\n        if (isBatchProcessing) return;\n        setIsBatchProcessing(true);\n        const plansToProcess = imagePlans.filter((p) => p.status !== 'done');\n        const promises = plansToProcess.map((plan) => generateSinglePlan(plan));\n        await Promise.all(promises);\n        setIsBatchProcessing(false);\n    }, [generateSinglePlan, imagePlans, isBatchProcessing]);\n\n    const autoPlanImages = useCallback(async () => {\n        const getContent = () => {\n            if (tiptapApi?.getPlainText) return tiptapApi.getPlainText();\n            return editorRef.current?.innerText || '';\n        };\n        if (isPlanning) return;\n        setIsPlanning(true);\n        try {\n            const content = getContent();\n            const res = await planImagesForArticle(content, scrapedImages, targetAudience, visualStyle || '');\n            setImagePlans(res.data);\n            onAddCost?.(res.cost, res.usage);\n        } catch (e) {\n            console.error('Auto-plan failed', e);\n            alert('Failed to plan images.');\n        } finally {\n            setIsPlanning(false);\n        }\n    }, [editorRef, onAddCost, scrapedImages, targetAudience, visualStyle, isPlanning]);\n\n    return {\n        showImageModal,\n        setShowImageModal,\n        imagePrompt,\n        setImagePrompt,\n        isImageLoading,\n        isDownloadingImages,\n        imagePlans,\n        isPlanning,\n        isBatchProcessing,\n        openImageModal,\n        generateImageFromPrompt,\n        downloadImages,\n        autoPlanImages,\n        updatePlanPrompt,\n        injectImageIntoEditor,\n        generateSinglePlan,\n        handleBatchProcess,\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 954, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useMetaGenerator.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport { generateSnippet } from '../services/generation/contentGenerationService';\nimport { TargetAudience, CostBreakdown, TokenUsage, ProductBrief } from '../types';\nimport { promptTemplates } from '../services/engine/promptTemplates';\nimport { Type } from '../services/engine/schemaTypes';\nimport { aiService } from '../services/engine/aiService';\n\ninterface MetaContext {\n    keyPoints: string[];\n    brandExclusivePoints: string[];\n    productBrief?: ProductBrief | null;\n    visualStyle?: string;\n    outlineSections?: string[];\n}\n\ninterface UseMetaGeneratorParams {\n    editorRef: React.RefObject<HTMLDivElement>;\n    tiptapApi?: { getPlainText: () => string } | null;\n    targetAudience: TargetAudience;\n    context: MetaContext;\n    onAddCost?: (cost: CostBreakdown, usage: TokenUsage) => void;\n    onMetaGenerated?: (meta: { title: string; description: string; slug: string }) => void;\n}\n\nexport const useMetaGenerator = ({\n    editorRef,\n    tiptapApi,\n    targetAudience,\n    context,\n    onAddCost,\n    onMetaGenerated,\n}: UseMetaGeneratorParams) => {\n    const [metaTitle, setMetaTitle] = useState('');\n    const [metaDescription, setMetaDescription] = useState('');\n    const [urlSlug, setUrlSlug] = useState('');\n    const [isMetaLoading, setIsMetaLoading] = useState(false);\n\n    const generateMeta = useCallback(async () => {\n        setIsMetaLoading(true);\n        try {\n            const articleText = (tiptapApi?.getPlainText ? tiptapApi.getPlainText() : editorRef.current?.innerText || '').slice(0, 1000);\n            const contextLines: string[] = [];\n            if (context.keyPoints.length > 0) contextLines.push(`Key Points: ${context.keyPoints.slice(0, 6).join('; ')} `);\n            if (context.brandExclusivePoints.length > 0) contextLines.push(`Brand USPs: ${context.brandExclusivePoints.slice(0, 4).join('; ')} `);\n            if (context.productBrief?.brandName || context.productBrief?.productName) {\n                contextLines.push(`Brand: ${context.productBrief?.brandName || ''} Product: ${context.productBrief?.productName || ''} USP: ${context.productBrief?.usp || ''} `);\n            }\n            if (context.visualStyle) contextLines.push(`Visual Style: ${context.visualStyle} `);\n            if (context.outlineSections && context.outlineSections.length > 0) {\n                const outlinePreview = context.outlineSections.slice(0, 8).join(' > ');\n                contextLines.push(`Outline: ${outlinePreview} `);\n            }\n\n            const metaPrompt = promptTemplates.metaSeo({\n                targetAudience,\n                contextLines,\n                articlePreview: articleText,\n            });\n\n            const res = await generateSnippet(metaPrompt, targetAudience, {\n                responseMimeType: 'application/json',\n                responseSchema: {\n                    type: Type.OBJECT,\n                    properties: {\n                        title: { type: Type.STRING },\n                        description: { type: Type.STRING },\n                        slug: { type: Type.STRING }\n                    }\n                },\n                // Force JSON and minimal verbosity\n                generationConfig: {\n                    response_mime_type: 'application/json'\n                }\n            });\n\n            const parsed = JSON.parse(res.data || '{}');\n            const title = parsed.title || metaTitle || '';\n            const description = parsed.description || metaDescription || '';\n            const slug = parsed.slug || metaTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || '';\n            setMetaTitle(title);\n            setMetaDescription(description);\n            setUrlSlug(slug);\n            onMetaGenerated?.({ title, description, slug });\n            onAddCost?.(res.cost, res.usage);\n        } catch (err) {\n            console.error('Meta generation failed', err);\n            alert('Failed to generate meta info. Please try again.');\n        } finally {\n            setIsMetaLoading(false);\n        }\n    }, [\n        context.brandExclusivePoints,\n        context.keyPoints,\n        context.productBrief,\n        context.visualStyle,\n        context.outlineSections,\n        editorRef,\n        onAddCost,\n        onMetaGenerated,\n        targetAudience\n    ]);\n\n    return {\n        metaTitle,\n        metaDescription,\n        urlSlug,\n        setMetaTitle,\n        setMetaDescription,\n        setUrlSlug,\n        isMetaLoading,\n        generateMeta,\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useAskAi.ts"],"sourcesContent":["import { useCallback, useRef } from 'react';\nimport { marked } from 'marked';\nimport { generateSnippet } from '../services/generation/contentGenerationService';\nimport { getLanguageInstruction } from '../services/engine/promptService';\nimport type { AskAiRunActionInput } from '../components/AskAiSelection';\nimport { TargetAudience, CostBreakdown, TokenUsage } from '../types';\n\ntype AskAiMode = 'edit' | 'format';\n\ntype TiptapApi = {\n    getSelectedText: () => string;\n    insertHtml: (html: string) => void;\n    getPlainText: () => string;\n    getHtml: () => string;\n    setHtml: (html: string) => void;\n    getSelectionRange: () => { from: number; to: number };\n    replaceRange: (range: { from: number; to: number }, html: string) => void;\n    markAskAiRange: (range: { from: number; to: number }, taskId: string) => void;\n    clearAskAiMarks: (taskId?: string) => void;\n    findAskAiRange: (taskId: string) => { from: number; to: number } | null;\n    clearBold?: (options?: { removeBold?: boolean; removeBlockquotes?: boolean; removeQuotes?: boolean; target?: 'selection' | 'document' }) => boolean;\n    summarizeFormatting?: () => { boldMarks: number; blockquotes: number; quoteChars: number };\n};\n\ninterface UseAskAiParams {\n    tiptapApi: TiptapApi | null;\n    targetAudience: TargetAudience;\n    onAddCost?: (cost: CostBreakdown, usage: TokenUsage) => void;\n    setIsAiLoading: (loading: boolean) => void;\n    updateCountsFromText: (text: string) => void;\n    onChange?: (html: string) => void;\n}\n\nexport const useAskAi = ({\n    tiptapApi,\n    targetAudience,\n    onAddCost,\n    setIsAiLoading,\n    updateCountsFromText,\n    onChange,\n}: UseAskAiParams) => {\n    const askAiRangesRef = useRef<Record<string, { from: number; to: number }>>({});\n    const lastRangeRef = useRef<{ from: number; to: number } | null>(null);\n    const lastActionModeRef = useRef<AskAiMode | null>(null);\n    const pendingCountRef = useRef(0);\n\n    const clearAskAiState = useCallback(() => {\n        // Keep other task highlights; only clear generic marks if no task is specified.\n        lastActionModeRef.current = null;\n    }, [tiptapApi]);\n\n    const buildAskAiPrompt = useCallback((input: AskAiRunActionInput, text: string) => {\n        const languageInstruction = getLanguageInstruction(targetAudience);\n\n        if (input.mode === 'format') {\n            let task = '';\n            switch (input.preset) {\n                case 'bullet':\n                    task = 'Convert to a bullet list.';\n                    break;\n                case 'ordered':\n                    task = 'Convert to an ordered (numbered) list.';\n                    break;\n                case 'table-2':\n                    task = 'Present as a 2-column table (Header + Row values).';\n                    break;\n                case 'table-3':\n                    task = 'Present as a 3-column table (Header + Row values).';\n                    break;\n                case 'checklist':\n                    task = 'Convert to a checklist with unchecked boxes.';\n                    break;\n                case 'quote':\n                    task = 'Wrap as a highlighted quote block.';\n                    break;\n                case 'markdown-clean':\n                    task = 'Clean up Markdown/HTML, fix nesting, and keep structure minimal.';\n                    break;\n                default:\n                    task = 'Reformat cleanly.';\n            }\n            return `TARGET CONTENT: \"\"\"${text}\"\"\"\\nTASK: ${task} Return ONLY the formatted HTML/Markdown.\\n\\n${languageInstruction}`;\n        }\n\n        const presetInstruction = (() => {\n            switch (input.preset) {\n                case 'rephrase':\n                    return 'Rephrase for clarity while keeping meaning. Ensure the tone is natural and professional.';\n                case 'shorten':\n                    return 'CRITICAL: Condense the text by 30-50%. Remove all fluff, redundancy, and filler words. Keep ONLY the core message.';\n                case 'elaborate':\n                    return 'Expand with 1-2 concise sentences to add clarity.';\n                case 'formal':\n                    return 'Rewrite in a more formal tone.';\n                case 'casual':\n                    return 'Rewrite in a friendlier, more casual tone.';\n                case 'bulletise':\n                    return 'Convert into concise bullet points.';\n                case 'summarise':\n                    return 'Summarise into a brief paragraph or 2 bullets.';\n                default:\n                    return input.prompt || 'Improve the text with better flow.';\n            }\n        })();\n\n        return `TARGET TEXT: \"\"\"${text}\"\"\"\\nINSTRUCTION: ${presetInstruction}${input.prompt ? `\\nCUSTOM PROMPT: ${input.prompt}` : ''}\\n\\n${languageInstruction}\\n\\nTASK: Return ONLY the rewritten result in HTML/Markdown.`;\n    }, [targetAudience]);\n\n    const lockAskAiRange = useCallback((taskId?: string) => {\n        if (!tiptapApi) return null;\n        const selectionRange = tiptapApi.getSelectionRange?.() || null;\n        if (selectionRange) {\n            lastRangeRef.current = selectionRange;\n            if (taskId) {\n                askAiRangesRef.current[taskId] = selectionRange;\n                tiptapApi.markAskAiRange?.(selectionRange, taskId);\n            }\n        }\n        return selectionRange;\n    }, [tiptapApi]);\n\n    const runAskAiAction = useCallback(async (input: AskAiRunActionInput) => {\n        if (!tiptapApi) {\n            alert('Editor not ready.');\n            throw new Error('Editor not ready');\n        }\n        const selectionRange =\n            (input.taskId ? tiptapApi.findAskAiRange?.(input.taskId) : null) ||\n            (input.taskId ? askAiRangesRef.current[input.taskId] : null) ||\n            lastRangeRef.current ||\n            tiptapApi.getSelectionRange?.() ||\n            null;\n        lastActionModeRef.current = input.mode;\n        if (selectionRange) {\n            lastRangeRef.current = selectionRange;\n            if (input.taskId) {\n                askAiRangesRef.current[input.taskId] = selectionRange;\n            }\n        }\n        const selectedText = (input.selectedText || tiptapApi.getSelectedText?.() || '').trim();\n        if (!selectedText) {\n            alert('請先選取要調整的文字。');\n            throw new Error('No selection');\n        }\n        if (selectionRange && input.taskId) {\n            tiptapApi.markAskAiRange?.(selectionRange, input.taskId);\n        }\n        const promptToSend = buildAskAiPrompt(input, selectedText);\n\n        pendingCountRef.current += 1;\n        setIsAiLoading(true);\n        try {\n            const res = await generateSnippet(promptToSend, targetAudience as TargetAudience);\n            const htmlSnippet = marked.parse(res.data || '', { async: false }) as string;\n            onAddCost?.(res.cost, res.usage);\n            return htmlSnippet;\n        } catch (error) {\n            console.error(\"AI Edit failed\", error);\n            alert(\"Failed to generate content. Please try again.\");\n            throw error;\n        } finally {\n            pendingCountRef.current = Math.max(0, pendingCountRef.current - 1);\n            setIsAiLoading(pendingCountRef.current > 0);\n        }\n    }, [buildAskAiPrompt, onAddCost, setIsAiLoading, targetAudience, tiptapApi]);\n\n    const handleAskAiInsert = useCallback((html: string, taskId?: string) => {\n        if (!tiptapApi) return;\n        const selectionRange =\n            (taskId ? tiptapApi.findAskAiRange?.(taskId) : null) ||\n            (taskId ? askAiRangesRef.current[taskId] : null) ||\n            lastRangeRef.current ||\n            tiptapApi.getSelectionRange?.();\n        const mode = lastActionModeRef.current;\n        if (selectionRange) {\n            tiptapApi.replaceRange(selectionRange, html);\n        } else {\n            tiptapApi.insertHtml(html);\n        }\n        if (taskId) {\n            delete askAiRangesRef.current[taskId];\n            tiptapApi.clearAskAiMarks?.(taskId);\n        }\n        clearAskAiState();\n        const updatedText = tiptapApi.getPlainText();\n        updateCountsFromText(updatedText);\n        onChange?.(tiptapApi.getHtml());\n    }, [clearAskAiState, onChange, tiptapApi, updateCountsFromText]);\n\n    return {\n        runAskAiAction,\n        handleAskAiInsert,\n        clearAskAiState,\n        lockAskAiRange,\n        highlightAskAiTarget: (taskId: string) => {\n            const range = tiptapApi?.findAskAiRange?.(taskId);\n            if (range) {\n                tiptapApi?.markAskAiRange?.(range, taskId);\n            }\n        },\n    };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;AA8BO,MAAM,WAAW,CAAC,EACrB,SAAS,EACT,cAAc,EACd,SAAS,EACT,cAAc,EACd,oBAAoB,EACpB,QAAQ,EACK;;IACb,MAAM,iBAAiB,IAAA,uKAAM,EAA+C,CAAC;IAC7E,MAAM,eAAe,IAAA,uKAAM,EAAsC;IACjE,MAAM,oBAAoB,IAAA,uKAAM,EAAmB;IACnD,MAAM,kBAAkB,IAAA,uKAAM,EAAC;IAE/B,MAAM,kBAAkB,IAAA,4KAAW;iDAAC;YAChC,gFAAgF;YAChF,kBAAkB,OAAO,GAAG;QAChC;gDAAG;QAAC;KAAU;IAEd,MAAM,mBAAmB,IAAA,4KAAW;kDAAC,CAAC,OAA4B;YAC9D,MAAM,sBAAsB,IAAA,uKAAsB,EAAC;YAEnD,IAAI,MAAM,IAAI,KAAK,UAAU;gBACzB,IAAI,OAAO;gBACX,OAAQ,MAAM,MAAM;oBAChB,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ,KAAK;wBACD,OAAO;wBACP;oBACJ;wBACI,OAAO;gBACf;gBACA,OAAO,CAAC,mBAAmB,EAAE,KAAK,WAAW,EAAE,KAAK,6CAA6C,EAAE,qBAAqB;YAC5H;YAEA,MAAM,oBAAoB;4EAAC;oBACvB,OAAQ,MAAM,MAAM;wBAChB,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX,KAAK;4BACD,OAAO;wBACX;4BACI,OAAO,MAAM,MAAM,IAAI;oBAC/B;gBACJ;aAAC;YAED,OAAO,CAAC,gBAAgB,EAAE,KAAK,kBAAkB,EAAE,oBAAoB,MAAM,MAAM,GAAG,CAAC,iBAAiB,EAAE,MAAM,MAAM,EAAE,GAAG,GAAG,IAAI,EAAE,oBAAoB,4DAA4D,CAAC;QACzN;iDAAG;QAAC;KAAe;IAEnB,MAAM,iBAAiB,IAAA,4KAAW;gDAAC,CAAC;YAChC,IAAI,CAAC,WAAW,OAAO;YACvB,MAAM,iBAAiB,UAAU,iBAAiB,QAAQ;YAC1D,IAAI,gBAAgB;gBAChB,aAAa,OAAO,GAAG;gBACvB,IAAI,QAAQ;oBACR,eAAe,OAAO,CAAC,OAAO,GAAG;oBACjC,UAAU,cAAc,GAAG,gBAAgB;gBAC/C;YACJ;YACA,OAAO;QACX;+CAAG;QAAC;KAAU;IAEd,MAAM,iBAAiB,IAAA,4KAAW;gDAAC,OAAO;YACtC,IAAI,CAAC,WAAW;gBACZ,MAAM;gBACN,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,iBACF,CAAC,MAAM,MAAM,GAAG,UAAU,cAAc,GAAG,MAAM,MAAM,IAAI,IAAI,KAC/D,CAAC,MAAM,MAAM,GAAG,eAAe,OAAO,CAAC,MAAM,MAAM,CAAC,GAAG,IAAI,KAC3D,aAAa,OAAO,IACpB,UAAU,iBAAiB,QAC3B;YACJ,kBAAkB,OAAO,GAAG,MAAM,IAAI;YACtC,IAAI,gBAAgB;gBAChB,aAAa,OAAO,GAAG;gBACvB,IAAI,MAAM,MAAM,EAAE;oBACd,eAAe,OAAO,CAAC,MAAM,MAAM,CAAC,GAAG;gBAC3C;YACJ;YACA,MAAM,eAAe,CAAC,MAAM,YAAY,IAAI,UAAU,eAAe,QAAQ,EAAE,EAAE,IAAI;YACrF,IAAI,CAAC,cAAc;gBACf,MAAM;gBACN,MAAM,IAAI,MAAM;YACpB;YACA,IAAI,kBAAkB,MAAM,MAAM,EAAE;gBAChC,UAAU,cAAc,GAAG,gBAAgB,MAAM,MAAM;YAC3D;YACA,MAAM,eAAe,iBAAiB,OAAO;YAE7C,gBAAgB,OAAO,IAAI;YAC3B,eAAe;YACf,IAAI;gBACA,MAAM,MAAM,MAAM,IAAA,+KAAe,EAAC,cAAc;gBAChD,MAAM,cAAc,2JAAM,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,IAAI;oBAAE,OAAO;gBAAM;gBAChE,YAAY,IAAI,IAAI,EAAE,IAAI,KAAK;gBAC/B,OAAO;YACX,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,kBAAkB;gBAChC,MAAM;gBACN,MAAM;YACV,SAAU;gBACN,gBAAgB,OAAO,GAAG,KAAK,GAAG,CAAC,GAAG,gBAAgB,OAAO,GAAG;gBAChE,eAAe,gBAAgB,OAAO,GAAG;YAC7C;QACJ;+CAAG;QAAC;QAAkB;QAAW;QAAgB;QAAgB;KAAU;IAE3E,MAAM,oBAAoB,IAAA,4KAAW;mDAAC,CAAC,MAAc;YACjD,IAAI,CAAC,WAAW;YAChB,MAAM,iBACF,CAAC,SAAS,UAAU,cAAc,GAAG,UAAU,IAAI,KACnD,CAAC,SAAS,eAAe,OAAO,CAAC,OAAO,GAAG,IAAI,KAC/C,aAAa,OAAO,IACpB,UAAU,iBAAiB;YAC/B,MAAM,OAAO,kBAAkB,OAAO;YACtC,IAAI,gBAAgB;gBAChB,UAAU,YAAY,CAAC,gBAAgB;YAC3C,OAAO;gBACH,UAAU,UAAU,CAAC;YACzB;YACA,IAAI,QAAQ;gBACR,OAAO,eAAe,OAAO,CAAC,OAAO;gBACrC,UAAU,eAAe,GAAG;YAChC;YACA;YACA,MAAM,cAAc,UAAU,YAAY;YAC1C,qBAAqB;YACrB,WAAW,UAAU,OAAO;QAChC;kDAAG;QAAC;QAAiB;QAAU;QAAW;KAAqB;IAE/D,OAAO;QACH;QACA;QACA;QACA;QACA,sBAAsB,CAAC;YACnB,MAAM,QAAQ,WAAW,iBAAiB;YAC1C,IAAI,OAAO;gBACP,WAAW,iBAAiB,OAAO;YACvC;QACJ;IACJ;AACJ;GAxKa"}},
    {"offset": {"line": 1261, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useEditorAutosave.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\n\ntype MetaState = {\n    metaTitle?: string;\n    metaDescription?: string;\n    urlSlug?: string;\n    articleTitle?: string;\n};\n\ninterface UseEditorAutosaveParams {\n    storageKey?: string;\n    debounceMs?: number;\n}\n\nexport const useEditorAutosave = ({\n    storageKey = 'ai_writer_editor_autosave_v1',\n    debounceMs = 3000\n}: UseEditorAutosaveParams) => {\n    const autosaveTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n    const latestHtmlRef = useRef<string>('');\n    const latestMetaRef = useRef<MetaState>({});\n    const pendingRestoreRef = useRef<any | null>(null);\n    const lastSavedRef = useRef<string>(''); // cache serialized payload to avoid redundant writes\n\n    // Load saved draft on mount\n    useEffect(() => {\n        if (typeof window === 'undefined') return;\n        try {\n            const savedRaw = localStorage.getItem(storageKey);\n            if (!savedRaw) return;\n            const saved = JSON.parse(savedRaw);\n            if (saved && saved.html) {\n                pendingRestoreRef.current = saved;\n            }\n        } catch (e) {\n            console.warn('Failed to read autosave', e);\n        }\n    }, [storageKey]);\n\n    const queueAutosave = useCallback(() => {\n        if (typeof window === 'undefined') return;\n        if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);\n        autosaveTimerRef.current = setTimeout(() => {\n            const payload = {\n                html: latestHtmlRef.current || '',\n                ...latestMetaRef.current,\n                ts: Date.now(),\n            };\n            if (!payload.html.trim()) return;\n            const serialized = JSON.stringify(payload);\n            if (serialized === lastSavedRef.current) return;\n            try {\n                localStorage.setItem(storageKey, serialized);\n                lastSavedRef.current = serialized;\n            } catch (e) {\n                console.warn('Autosave failed', e);\n            }\n        }, debounceMs);\n    }, [debounceMs, storageKey]);\n\n    const recordHtml = useCallback((html: string) => {\n        latestHtmlRef.current = html || '';\n        queueAutosave();\n    }, [queueAutosave]);\n\n    const recordMeta = useCallback((meta: MetaState) => {\n        latestMetaRef.current = { ...latestMetaRef.current, ...meta };\n        queueAutosave();\n    }, [queueAutosave]);\n\n    const consumeDraft = useCallback(() => {\n        const saved = pendingRestoreRef.current;\n        pendingRestoreRef.current = null;\n        return saved as (MetaState & { html: string }) | null;\n    }, []);\n\n    return { recordHtml, recordMeta, consumeDraft };\n};\n"],"names":[],"mappings":";;;;AAAA;;;AAcO,MAAM,oBAAoB,CAAC,EAC9B,aAAa,8BAA8B,EAC3C,aAAa,IAAI,EACK;;IACtB,MAAM,mBAAmB,IAAA,uKAAM,EAAuC;IACtE,MAAM,gBAAgB,IAAA,uKAAM,EAAS;IACrC,MAAM,gBAAgB,IAAA,uKAAM,EAAY,CAAC;IACzC,MAAM,oBAAoB,IAAA,uKAAM,EAAa;IAC7C,MAAM,eAAe,IAAA,uKAAM,EAAS,KAAK,qDAAqD;IAE9F,4BAA4B;IAC5B,IAAA,0KAAS;uCAAC;YACN;;YACA,IAAI;gBACA,MAAM,WAAW,aAAa,OAAO,CAAC;gBACtC,IAAI,CAAC,UAAU;gBACf,MAAM,QAAQ,KAAK,KAAK,CAAC;gBACzB,IAAI,SAAS,MAAM,IAAI,EAAE;oBACrB,kBAAkB,OAAO,GAAG;gBAChC;YACJ,EAAE,OAAO,GAAG;gBACR,QAAQ,IAAI,CAAC,2BAA2B;YAC5C;QACJ;sCAAG;QAAC;KAAW;IAEf,MAAM,gBAAgB,IAAA,4KAAW;wDAAC;YAC9B;;YACA,IAAI,iBAAiB,OAAO,EAAE,aAAa,iBAAiB,OAAO;YACnE,iBAAiB,OAAO,GAAG;gEAAW;oBAClC,MAAM,UAAU;wBACZ,MAAM,cAAc,OAAO,IAAI;wBAC/B,GAAG,cAAc,OAAO;wBACxB,IAAI,KAAK,GAAG;oBAChB;oBACA,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,IAAI;oBAC1B,MAAM,aAAa,KAAK,SAAS,CAAC;oBAClC,IAAI,eAAe,aAAa,OAAO,EAAE;oBACzC,IAAI;wBACA,aAAa,OAAO,CAAC,YAAY;wBACjC,aAAa,OAAO,GAAG;oBAC3B,EAAE,OAAO,GAAG;wBACR,QAAQ,IAAI,CAAC,mBAAmB;oBACpC;gBACJ;+DAAG;QACP;uDAAG;QAAC;QAAY;KAAW;IAE3B,MAAM,aAAa,IAAA,4KAAW;qDAAC,CAAC;YAC5B,cAAc,OAAO,GAAG,QAAQ;YAChC;QACJ;oDAAG;QAAC;KAAc;IAElB,MAAM,aAAa,IAAA,4KAAW;qDAAC,CAAC;YAC5B,cAAc,OAAO,GAAG;gBAAE,GAAG,cAAc,OAAO;gBAAE,GAAG,IAAI;YAAC;YAC5D;QACJ;oDAAG;QAAC;KAAc;IAElB,MAAM,eAAe,IAAA,4KAAW;uDAAC;YAC7B,MAAM,QAAQ,kBAAkB,OAAO;YACvC,kBAAkB,OAAO,GAAG;YAC5B,OAAO;QACX;sDAAG,EAAE;IAEL,OAAO;QAAE;QAAY;QAAY;IAAa;AAClD;GA/Da"}},
    {"offset": {"line": 1362, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/generation/generationLogger.ts"],"sourcesContent":["import { useGenerationStore } from '../../store/useGenerationStore';\n\nexport const appendAnalysisLog = (msg: string) => {\n    const store = useGenerationStore.getState();\n    // Only append logs to content during the analysis phase\n    if (store.status === 'analyzing') {\n        // store.setContent(prev => {\n        //     const next = typeof prev === 'string' ? prev : '';\n        //     return next ? `${next}\\n${msg}` : msg;\n        // });\n        console.log(`[Analysis Log]: ${msg}`);\n    } else {\n        console.log(`[Background Log]: ${msg}`);\n    }\n};\n\nexport const summarizeList = (items: string[], max: number = 5) => {\n    const slice = items.slice(0, max);\n    const more = items.length > max ? ` +${items.length - max}` : '';\n    return slice.join(', ') + more;\n};\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,oBAAoB,CAAC;IAC9B,MAAM,QAAQ,2JAAkB,CAAC,QAAQ;IACzC,wDAAwD;IACxD,IAAI,MAAM,MAAM,KAAK,aAAa;QAC9B,6BAA6B;QAC7B,yDAAyD;QACzD,6CAA6C;QAC7C,MAAM;QACN,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,KAAK;IACxC,OAAO;QACH,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,KAAK;IAC1C;AACJ;AAEO,MAAM,gBAAgB,CAAC,OAAiB,MAAc,CAAC;IAC1D,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAG;IAC7B,MAAM,OAAO,MAAM,MAAM,GAAG,MAAM,CAAC,EAAE,EAAE,MAAM,MAAM,GAAG,KAAK,GAAG;IAC9D,OAAO,MAAM,IAAI,CAAC,QAAQ;AAC9B"}},
    {"offset": {"line": 1395, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/generation/useAnalysisPipeline.ts"],"sourcesContent":["import { ArticleConfig, SectionAnalysis } from '../../types';\nimport { useGenerationStore } from '../../store/useGenerationStore';\nimport { useAnalysisStore } from '../../store/useAnalysisStore';\nimport { useMetricsStore } from '../../store/useMetricsStore';\nimport { parseProductContext, generateProblemProductMapping } from '../../services/research/productFeatureToPainPointMapper';\nimport { analyzeText } from '../../services/engine/nlpService';\nimport { extractSemanticKeywordsAnalysis } from '../../services/research/termUsagePlanner';\nimport { SEMANTIC_KEYWORD_LIMIT } from '../../config/constants';\nimport { useSettingsStore } from '../../store/useSettingsStore';\nimport { analyzeReferenceStructure } from '../../services/research/referenceAnalysisService';\nimport { analyzeAuthorityTerms } from '../../services/research/authorityService';\nimport { analyzeImageWithAI, analyzeVisualStyle } from '../../services/generation/imageService';\nimport { appendAnalysisLog, summarizeList } from './generationLogger';\nimport { getLanguageInstruction } from '../../services/engine/promptService';\n\nimport { cleanHeadingText } from '../../utils/textUtils';\nimport { analyzeRegionalTerms } from '../../services/research/regionalAnalysisService';\n\n\nconst isStopped = () => useGenerationStore.getState().isStopped;\nconst audienceLabel = (aud: ArticleConfig['targetAudience']) => {\n    switch (aud) {\n        case 'zh-HK': return '繁體中文（香港）';\n        case 'zh-MY': return '簡體中文（馬來西亞）';\n        case 'zh-TW':\n        default:\n            return '繁體中文（台灣）';\n    }\n};\n\n\n\nexport const runAnalysisPipeline = async (config: ArticleConfig) => {\n    const generationStore = useGenerationStore.getState();\n    const analysisStore = useAnalysisStore.getState();\n    const metricsStore = useMetricsStore.getState();\n\n    // Reset State for Analysis\n    generationStore.setStatus('analyzing');\n    analysisStore.setScrapedImages(config.scrapedImages || []);\n    analysisStore.setTargetAudience(config.targetAudience);\n    analysisStore.setArticleTitle(config.title || '');\n    const languageInstruction = getLanguageInstruction(config.targetAudience);\n    analysisStore.setLanguageInstruction(languageInstruction);\n    console.info('[LangConfig]', { targetAudience: config.targetAudience, languageInstruction });\n    appendAnalysisLog(`語言設定：${audienceLabel(config.targetAudience)}（${config.targetAudience}）`);\n    appendAnalysisLog('Starting analysis...');\n\n    const fullConfig = {\n        ...config,\n        brandKnowledge: analysisStore.brandKnowledge\n    };\n\n    // Task 1: Product Context\n    const productTask = async () => {\n        let parsedProductBrief = config.productBrief;\n        let generatedMapping: any[] = [];\n\n        if (!parsedProductBrief && config.productRawText && config.productRawText.length > 5) {\n            if (isStopped()) return { mapping: [] };\n            generationStore.setGenerationStep('parsing_product');\n            appendAnalysisLog('Parsing product brief and CTA...');\n            const parseRes = await parseProductContext(config.productRawText);\n            console.log(`[Timer] Product Context Parse: ${parseRes.duration}ms`);\n            parsedProductBrief = parseRes.data;\n            appendAnalysisLog('Product brief parsed.');\n            metricsStore.addCost(parseRes.cost.totalCost, parseRes.usage.totalTokens);\n        }\n\n        if (parsedProductBrief && parsedProductBrief.productName) {\n            if (isStopped()) return { brief: parsedProductBrief, mapping: [] };\n            generationStore.setGenerationStep('mapping_product');\n            appendAnalysisLog('Mapping pain points to product features...');\n            const mapRes = await generateProblemProductMapping(parsedProductBrief, fullConfig.targetAudience);\n            console.log(`[Timer] Product Mapping: ${mapRes.duration}ms`);\n            generatedMapping = mapRes.data;\n            analysisStore.setProductMapping(generatedMapping);\n            if (generatedMapping.length > 0) {\n                const example = generatedMapping[0];\n                appendAnalysisLog(`Product-feature mapping ready (${generatedMapping.length}). e.g., ${example.painPoint} → ${example.productFeature}`);\n            } else {\n                appendAnalysisLog('Product-feature mapping ready (no matches found).');\n            }\n            metricsStore.addCost(mapRes.cost.totalCost, mapRes.usage.totalTokens);\n        }\n\n        analysisStore.setActiveProductBrief(parsedProductBrief);\n        return { brief: parsedProductBrief, mapping: generatedMapping };\n    };\n\n    // Task 1.5: Heading refinement for preview (uses extracted structure titles)\n\n\n    // Task 2: NLP & Keyword Planning\n    const keywordTask = async () => {\n        if (isStopped()) return;\n        generationStore.setGenerationStep('nlp_analysis');\n        appendAnalysisLog('Running NLP keyword scan...');\n        const keywords = await analyzeText(fullConfig.referenceContent);\n\n        // DYNAMIC LIMIT CALCULATION:\n        const settings = useSettingsStore.getState();\n        const contentLen = fullConfig.referenceContent.length;\n        const calculatedLimit = Math.floor(contentLen / settings.keywordCharDivisor);\n        const finalLimit = Math.max(settings.minKeywords, Math.min(settings.maxKeywords, calculatedLimit));\n\n        const keywordPlanCandidates = keywords.slice(0, finalLimit);\n        const topTokens = summarizeList(keywordPlanCandidates.map(k => k.token), 6);\n        appendAnalysisLog(`NLP scan found ${keywords.length} keywords. Using top ${keywordPlanCandidates.length} (Ratio: 1/${settings.keywordCharDivisor}, Min: ${settings.minKeywords}): ${topTokens}`);\n\n        if (keywordPlanCandidates.length > 0 && !isStopped()) {\n            generationStore.setGenerationStep('planning_keywords');\n            try {\n                appendAnalysisLog(`Planning keyword strategy (top ${keywordPlanCandidates.length})...`);\n                const planRes = await extractSemanticKeywordsAnalysis(fullConfig.referenceContent, keywords, fullConfig.targetAudience);\n                console.log(`[Timer] Keyword Action Plan: ${planRes.duration}ms`);\n                console.log(`[SemanticKeywords] Final aggregated plans: ${planRes.data.length} / ${keywordPlanCandidates.length}`);\n                analysisStore.setKeywordPlans(planRes.data);\n                const planWords = summarizeList(planRes.data.map(p => p.word), 6);\n                appendAnalysisLog(`Keyword plan ready (${planRes.data.length}). Focus: ${planWords}`);\n                metricsStore.addCost(planRes.cost.totalCost, planRes.usage.totalTokens);\n            } catch (e) {\n                console.warn(\"Action Plan extraction failed\", e);\n                appendAnalysisLog('Keyword planning failed (continuing).');\n            }\n        }\n    };\n\n    // Task 3: Structure & Authority (run concurrently)\n    const structureTask = async () => {\n        if (isStopped()) return;\n        generationStore.setGenerationStep('extracting_structure');\n        appendAnalysisLog('Extracting reference structure and authority signals...');\n        const [structRes, authRes] = await Promise.all([\n            analyzeReferenceStructure(fullConfig.referenceContent, fullConfig.targetAudience),\n            analyzeAuthorityTerms(\n                fullConfig.authorityTerms || '',\n                fullConfig.title,\n                fullConfig.websiteType || 'General Professional Website',\n                fullConfig.targetAudience\n            )\n        ]);\n\n        console.log(`[Timer] Narrative Structure (Outline): ${structRes.duration}ms`);\n        console.log(`[Timer] Authority Analysis: ${authRes.duration}ms`);\n        appendAnalysisLog(`Structure extracted (${structRes.data?.structure?.length || 0} sections).`);\n        appendAnalysisLog('Authority terms mapped.');\n        if (structRes.data?.structure?.length) {\n            const sectionTitles = summarizeList(structRes.data.structure.map((s: any) => s.title), 6);\n            appendAnalysisLog(`Sections: ${sectionTitles}`);\n        }\n        if (authRes.data?.relevantTerms?.length) {\n            appendAnalysisLog(`Authority terms: ${summarizeList(authRes.data.relevantTerms, 6)}`);\n        }\n\n        metricsStore.addCost(structRes.cost.totalCost, structRes.usage.totalTokens);\n        metricsStore.addCost(authRes.cost.totalCost, authRes.usage.totalTokens);\n\n        analysisStore.setRefAnalysis(structRes.data);\n        analysisStore.setAuthAnalysis(authRes.data);\n\n        return { structRes, authRes };\n    };\n\n    // Task 4: Image Analysis & Visual Style\n    const visualTask = async () => {\n        if (isStopped()) return;\n        generationStore.setGenerationStep('analyzing_visuals');\n        appendAnalysisLog('Analyzing source images and visual identity...');\n\n        const initialImages = config.scrapedImages || [];\n        const imagesToAnalyze = initialImages.slice(0, 5);\n        let analyzedImages = [...initialImages];\n\n        if (imagesToAnalyze.length > 0) {\n            for (let i = 0; i < imagesToAnalyze.length; i++) {\n                if (isStopped()) break;\n                const img = imagesToAnalyze[i];\n                if (img.url) {\n                    try {\n                        const res = await analyzeImageWithAI(img.url);\n                        analyzedImages[i] = { ...analyzedImages[i], aiDescription: res.data };\n                        metricsStore.addCost(res.cost.totalCost, res.usage.totalTokens);\n                    } catch (e) {\n                        console.warn(`Failed to analyze image ${img.url}`, e);\n                    }\n                }\n            }\n            analysisStore.setScrapedImages(analyzedImages);\n        }\n\n        try {\n            const styleRes = await analyzeVisualStyle(analyzedImages, fullConfig.websiteType || \"Modern Business\");\n            analysisStore.setVisualStyle(styleRes.data);\n            appendAnalysisLog(`✓ Visual style extracted: ${styleRes.data}`);\n            metricsStore.addCost(styleRes.cost.totalCost, styleRes.usage.totalTokens);\n        } catch (e) {\n            console.warn(\"Failed to extract visual style\", e);\n            appendAnalysisLog('Visual style extraction skipped.');\n        }\n    };\n\n\n\n    // Task 5: Regional Analysis (NEW)\n    const regionalTask = async () => {\n        if (isStopped()) return;\n        generationStore.setGenerationStep('localizing_hk'); // Reuse step label or create new 'analyzing_region'\n        appendAnalysisLog('Analyzing regional terminology & brand grounding...');\n\n        try {\n            const regionRes = await analyzeRegionalTerms(fullConfig.referenceContent, fullConfig.targetAudience);\n            console.log(`[Timer] Regional Analysis: ${regionRes.duration}ms`);\n\n            if (regionRes.data && regionRes.data.length > 0) {\n                appendAnalysisLog(`Regional analysis found ${regionRes.data.length} terms to correct.`);\n                // Store in refAnalysis (requires refAnalysis to be initialized first, or return it)\n                return regionRes.data;\n            } else {\n                appendAnalysisLog('Regional analysis: No major issues found.');\n                return [];\n            }\n        } catch (e) {\n            console.warn(\"Regional analysis failed\", e);\n            appendAnalysisLog('Regional analysis failed (continuing).');\n            return [];\n        }\n    };\n\n    // --- EXECUTE ALL TASKS WITH STAGGERING ---\n    // Burst protection: Start each major task 1 second apart to prevent proxy/backend overload\n    appendAnalysisLog('Dispatching analysis tasks with burst protection...');\n\n    const productResult = await productTask();\n    await new Promise(r => setTimeout(r, 1000));\n\n    const [structureResult, visualResultsPromise, regionalResult, keywordResult] = await Promise.all([\n        structureTask(),\n        (async () => {\n            await new Promise(r => setTimeout(r, 1000));\n            return visualTask();\n        })(),\n        (async () => {\n            await new Promise(r => setTimeout(r, 2000));\n            return regionalTask();\n        })(),\n        (async () => {\n            await new Promise(r => setTimeout(r, 3000));\n            return keywordTask();\n        })()\n    ]);\n\n    // Merge regional result into structureResult if available\n    if (structureResult?.structRes?.data) {\n        structureResult.structRes.data.regionalReplacements = regionalResult;\n        if (analysisStore.refAnalysis) {\n            analysisStore.setRefAnalysis({\n                ...analysisStore.refAnalysis,\n                regionalReplacements: regionalResult\n            });\n        }\n    }\n\n    appendAnalysisLog('All analysis tasks completed. Preparing to write...');\n    generationStore.setGenerationStep('idle');\n\n    return {\n        productResult,\n        structureResult,\n        keywordPromise: Promise.resolve(keywordResult),\n        visualPromise: Promise.resolve(visualResultsPromise),\n        regionalPromise: Promise.resolve(regionalResult)\n    };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1668, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/generation/useContentGenerator.ts"],"sourcesContent":["import { ArticleConfig, SectionAnalysis } from '../../types';\nimport { useGenerationStore } from '../../store/useGenerationStore';\nimport { useAnalysisStore } from '../../store/useAnalysisStore';\nimport { useMetricsStore } from '../../store/useMetricsStore';\nimport { generateSectionContent } from '../../services/generation/contentGenerationService';\nimport { mergeTurboSections } from '../../services/generation/contentDisplayService';\n\n\nimport { cleanHeadingText, stripLeadingHeading } from '../../utils/textUtils';\nimport { planImagesForArticle, generateImage } from '../../services/generation/imageService';\nimport { appendAnalysisLog } from './generationLogger';\nimport { aiService } from '../../services/engine/aiService';\n\nconst isStopped = () => useGenerationStore.getState().isStopped;\n\nexport const runContentGeneration = async (\n    config: ArticleConfig,\n    analysisResults: {\n        productResult: any;\n        structureResult: any;\n    }\n) => {\n    const generationStore = useGenerationStore.getState();\n    const analysisStore = useAnalysisStore.getState();\n    const metricsStore = useMetricsStore.getState();\n\n    const { productResult, structureResult } = analysisResults;\n    const parsedProductBrief = productResult?.brief;\n    const productMappingData = productResult?.mapping || [];\n    const refAnalysisData = structureResult?.structRes.data;\n    const authAnalysisData = structureResult?.authRes.data;\n\n    // 1. Determine Sections\n    let sectionsToGenerate: (Partial<SectionAnalysis> & { title: string; specificPlan?: string[] })[] = [];\n    let isUsingCustomOutline = false;\n\n    if (config.sampleOutline && config.sampleOutline.trim().length > 0) {\n        const lines = config.sampleOutline.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n        sectionsToGenerate = lines.map(title => ({ title }));\n        isUsingCustomOutline = true;\n    } else if (refAnalysisData?.structure && refAnalysisData.structure.length > 0) {\n        sectionsToGenerate = [...refAnalysisData.structure]; // Clone to avoid mutating original\n\n        // Inject Introduction if available\n        if (refAnalysisData.introText && refAnalysisData.introText.trim().length > 0) {\n            sectionsToGenerate.unshift({\n                title: \"前言\", // Use generic Intro title\n                narrativePlan: [refAnalysisData.introText],\n                subheadings: [],\n                difficulty: 'easy'\n            });\n        }\n        isUsingCustomOutline = false;\n    } else {\n        sectionsToGenerate = [\n            { title: \"Introduction\" },\n            { title: \"Core Concepts\" },\n            { title: \"Benefits\" },\n            { title: \"Applications\" },\n            { title: \"Conclusion\" }\n        ];\n    }\n\n    generationStore.setStatus('streaming');\n    generationStore.setGenerationStep('writing_content');\n    generationStore.setContent('');\n\n    const headingOptimizations = analysisStore.headingOptimizations || [];\n    const shouldUseHeadingAnalysis = !isUsingCustomOutline && headingOptimizations.length > 0;\n\n    const resolveHeadingFromOptimizer = (title: string): string => {\n        const normalizedTitle = cleanHeadingText(title);\n        if (!shouldUseHeadingAnalysis) return normalizedTitle;\n\n        const candidate = headingOptimizations.find(opt => {\n            const before = cleanHeadingText(opt.h2_before);\n            const after = cleanHeadingText(opt.h2_after);\n            return before === normalizedTitle || after === normalizedTitle;\n        });\n\n        if (!candidate) return normalizedTitle;\n\n        // Pick the highest scoring option from the optimizer; fallback to the suggested H2.\n        const scoredOptions = (candidate.h2_options || [])\n            .map(opt => ({\n                text: cleanHeadingText(opt.text || ''),\n                score: typeof opt.score === 'number' ? opt.score : undefined\n            }))\n            .filter(opt => opt.text && typeof opt.score === 'number')\n            .sort((a, b) => (b.score ?? -Infinity) - (a.score ?? -Infinity));\n\n        const fallback = cleanHeadingText(candidate.h2_after || candidate.h2_before || normalizedTitle);\n        return cleanHeadingText(scoredOptions[0]?.text || fallback || normalizedTitle);\n    };\n\n    const sectionBodies: string[] = new Array(sectionsToGenerate.length).fill(\"\");\n    const sectionHeadings: string[] = sectionsToGenerate.map((s) => resolveHeadingFromOptimizer(s.title));\n    const legacyKeyPoints = [\n        ...(Array.isArray(refAnalysisData?.keyInformationPoints) ? refAnalysisData.keyInformationPoints : []),\n        ...(Array.isArray(refAnalysisData?.brandExclusivePoints) ? refAnalysisData.brandExclusivePoints : [])\n    ];\n\n    const structuredKeyPoints = (refAnalysisData?.structure || []).flatMap((s: any) => [\n        ...(Array.isArray(s?.keyFacts) ? s.keyFacts : []),\n        ...(Array.isArray(s?.uspNotes) ? s.uspNotes : [])\n    ]).filter(Boolean);\n\n    const allKeyPoints = Array.from(new Set([...structuredKeyPoints, ...legacyKeyPoints])).filter(Boolean);\n\n    const generatorConfig = {\n        ...config,\n        productBrief: parsedProductBrief,\n        referenceAnalysis: refAnalysisData,\n        authorityAnalysis: authAnalysisData,\n    };\n\n    const shouldAutoPlanImages = Boolean(config.autoImagePlan);\n\n    const getHeading = (idx: number) => cleanHeadingText(sectionHeadings[idx] || sectionsToGenerate[idx]?.title || `Section ${idx + 1}`);\n\n    const renderSectionBlock = (idx: number, bodyOverride?: string) => {\n        const heading = getHeading(idx);\n        const body = typeof bodyOverride === 'string' ? bodyOverride : sectionBodies[idx];\n        if (body) return `## ${heading}\\n\\n${body}`;\n        return `## ${heading}\\n\\n_(Writing...)_`;\n    };\n\n    const renderTurboSections = () => mergeTurboSections(\n        sectionsToGenerate,\n        sectionBodies.map((body, idx) => body ? renderSectionBlock(idx, body) : \"\")\n    );\n\n    const renderProgressSections = () => sectionBodies\n        .map((_, idx) => renderSectionBlock(idx))\n        .join('\\n\\n');\n\n    const getKeywordPlans = () => useAnalysisStore.getState().keywordPlans || [];\n\n    const outlineSourceLabel = isUsingCustomOutline\n        ? `**User Custom Outline**`\n        : `**AI Narrative Structure (Outline)**`;\n\n    const initialDisplay = `> 📑 **Active Blueprint:** ${outlineSourceLabel}\\n\\n`;\n    generationStore.setContent(initialDisplay);\n\n    const promises = sectionsToGenerate.map(async (section, i) => {\n        if (isStopped()) return;\n\n        const allTitles = sectionsToGenerate.map(s => s.title);\n        const futureTitles = allTitles.slice(i + 1);\n        const analysisPlan = refAnalysisData?.structure.find((s: any) => s.title === section.title)?.narrativePlan;\n        const specificPlan = section.specificPlan || analysisPlan;\n        const sectionData = refAnalysisData?.structure.find((s: any) => s.title === section.title);\n        const sectionPoints = Array.from(new Set([\n            ...(Array.isArray(section.keyFacts) ? section.keyFacts : []),\n            ...(Array.isArray(section.uspNotes) ? section.uspNotes : []),\n            ...(Array.isArray(sectionData?.keyFacts) ? sectionData.keyFacts : []),\n            ...(Array.isArray(sectionData?.uspNotes) ? sectionData.uspNotes : []),\n            ...allKeyPoints\n        ])).filter(Boolean);\n\n        const loopConfig = { ...generatorConfig, productMapping: productMappingData };\n        const dummyPreviousContent = i > 0 ? [`[Preceding Section: ${allTitles[i - 1]}]`] : [];\n\n        try {\n            const res = await generateSectionContent(\n                loopConfig,\n                section.title,\n                specificPlan,\n                refAnalysisData?.generalPlan,\n                getKeywordPlans(),\n                dummyPreviousContent,\n                futureTitles,\n                authAnalysisData,\n                sectionPoints,\n                [],\n                0,\n                section\n            );\n\n            if (!isStopped()) {\n                sectionBodies[i] = stripLeadingHeading(res.data.content);\n                console.log(`[Timer - Turbo] Section '${section.title}': ${res.duration}ms`);\n\n                generationStore.setContent(renderTurboSections());\n                metricsStore.addCost(res.cost.totalCost, res.usage.totalTokens);\n\n                if (res.data.usedPoints && res.data.usedPoints.length > 0) {\n                    analysisStore.setCoveredPoints(prev => {\n                        const newUnique = res.data.usedPoints.filter(p => !prev.includes(p));\n                        return [...prev, ...newUnique];\n                    });\n                }\n            }\n        } catch (err) {\n            console.error(`Parallel gen error for ${section.title}`, err);\n            sectionBodies[i] = ''; // Suppress error message in content\n            generationStore.setContent(renderTurboSections());\n        }\n    });\n\n    await Promise.all(promises);\n\n    if (!isStopped()) {\n        generationStore.setContent(renderProgressSections());\n        // Auto-heading refinement disabled in favor of manual toolbar tool\n    }\n\n    if (!isStopped()) {\n        if (shouldAutoPlanImages) {\n            // --- IMAGE GENERATION PHASE ---\n            generationStore.setGenerationStep('generating_images');\n            const fullContent = sectionBodies.join('\\n\\n');\n\n            try {\n                appendAnalysisLog('Planning visual assets...');\n                const imagePlans = await planImagesForArticle(\n                    fullContent,\n                    analysisStore.scrapedImages,\n                    config.targetAudience,\n                    analysisStore.visualStyle\n                );\n\n                console.log(`[Images] Planned ${imagePlans.data.length} images`);\n                appendAnalysisLog(`Visual plan ready: ${imagePlans.data.length} images.`);\n                metricsStore.addCost(imagePlans.cost.totalCost, imagePlans.usage.totalTokens);\n\n                // Generate images in parallel (limit concurrency if needed, but for now all at once is fine for small batches)\n                const imagePromises = imagePlans.data.map(async (plan) => {\n                    if (isStopped()) return;\n                    try {\n                        const label = plan.category || plan.insertAfter || plan.id;\n                        appendAnalysisLog(`Generating image: ${label}...`);\n                        const imgRes = await generateImage(plan.generatedPrompt);\n\n                        if (imgRes.data) {\n                            // In a real app, you'd save this to a store or insert it into the content.\n                            // For now, we'll just log it and maybe append it to the end or store it.\n                            // TODO: Store generated images in a store for the UI to display or insert.\n                            console.log(`[Images] Generated: ${plan.id}`);\n                            metricsStore.addCost(imgRes.cost.totalCost, imgRes.usage.totalTokens);\n                        }\n                    } catch (e) {\n                        console.error(`Failed to generate image ${plan.id}`, e);\n                    }\n                });\n\n                await Promise.all(imagePromises);\n                appendAnalysisLog('Image generation completed.');\n\n            } catch (e) {\n                console.error(\"Image generation phase failed\", e);\n                appendAnalysisLog('Image generation failed.');\n            }\n        } else {\n            appendAnalysisLog('Skipping auto image planning (manual only).');\n        }\n\n        // --- REGION LOCALIZATION skipped as requested ---\n        generationStore.setGenerationStep('finalizing');\n        // FIX: Ensure immediate completion so the content is visible under the modal\n        generationStore.setStatus('completed');\n        generationStore.setGenerationStep('idle');\n    }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1899, "column": 0}, "map": {"version":3,"sources":["file:///Users/rose/Documents/this_month/write-content/best-ai-text-writer.com/src/hooks/useGeneration.ts"],"sourcesContent":["import { useCallback } from 'react';\nimport { useMutation } from '@tanstack/react-query';\nimport { ArticleConfig } from '@/types';\nimport { useGenerationStore } from '@/store/useGenerationStore';\nimport { useAnalysisStore } from '@/store/useAnalysisStore';\nimport { resetGenerationState } from '@/store/resetGenerationState';\nimport { runAnalysisPipeline } from './generation/useAnalysisPipeline';\nimport { runContentGeneration } from './generation/useContentGenerator';\n\nconst runAnalysisOnly = async (config: ArticleConfig) => {\n    const generationStore = useGenerationStore.getState();\n\n    // Reset State\n    resetGenerationState();\n    generationStore.setError(null);\n    generationStore.setLastConfig(config);\n\n    try {\n        // 1. Analysis Phase\n        const analysisResults = await runAnalysisPipeline(config);\n\n        if (useGenerationStore.getState().isStopped) return;\n\n        generationStore.setAnalysisResults(analysisResults);\n        generationStore.setStatus('analysis_ready');\n        generationStore.setGenerationStep('idle');\n\n    } catch (err: any) {\n        console.error(err);\n        generationStore.setError(err.message || \"An unexpected error occurred during generation.\");\n        generationStore.setStatus('error');\n        generationStore.setGenerationStep('idle');\n    }\n};\n\nconst runWritingPhase = async () => {\n    const generationStore = useGenerationStore.getState();\n    const analysisResults = generationStore.analysisResults;\n    const config = generationStore.lastConfig;\n\n    if (!analysisResults || !config) {\n        generationStore.setError('尚未完成分析，無法生成段落。請先執行分析。');\n        generationStore.setStatus('error');\n        return;\n    }\n\n    // Check for accumulated analysis errors\n    const missingData: string[] = [];\n    if (!analysisResults.structureResult?.structRes?.data?.structure?.length) missingData.push('文章架構 (Structure)');\n    if (!analysisResults.structureResult?.authRes?.data) missingData.push('權威分析 (Authority)');\n    if (!useAnalysisStore.getState().keywordPlans?.length) missingData.push('關鍵字規劃 (Keywords)');\n\n    if (missingData.length > 0) {\n        const confirmMsg = `偵測到部分分析資料缺失：\\n${missingData.map(s => `- ${s}`).join('\\n')}\\n\\n是否仍要嘗試生成？(選擇「取消」將重新執行分析)`;\n        if (!window.confirm(confirmMsg)) {\n            // User chose to retry analysis\n            // We need to trigger analysis again. Since we can't easily call the mutation from here without passing it in,\n            // we'll throw a special error or handle it in the component.\n            // Ideally, we should just return here and let the user click \"Generate\" again, \n            // but to be helpful we can reset the status so they can click \"Generate\" immediately.\n            generationStore.setStatus('idle');\n            return;\n        }\n    }\n\n    generationStore.setError(null);\n    try {\n        await runContentGeneration(config, analysisResults);\n    } catch (err: any) {\n        console.error(err);\n        generationStore.setError(err?.message || '生成段落時發生錯誤，請重試。');\n        generationStore.setStatus('error');\n        generationStore.setGenerationStep('idle');\n    }\n};\n\nexport const useGeneration = () => {\n    const mutation = useMutation({\n        mutationFn: (config: ArticleConfig) => runAnalysisOnly(config),\n    });\n\n    const writeMutation = useMutation({\n        mutationFn: () => runWritingPhase(),\n    });\n\n    const generate = useCallback(async (config: ArticleConfig) => {\n        const genState = useGenerationStore.getState();\n        const hasExistingAnalysis = !!genState.analysisResults;\n        const hasExistingContent = (genState.content || '').trim().length > 0;\n\n        if (hasExistingAnalysis || hasExistingContent) {\n            const confirmed = window.confirm('已經有分析結果或內容，重新分析會覆蓋目前的資料，確定要繼續嗎？');\n            if (!confirmed) return;\n        }\n\n        await mutation.mutateAsync(config);\n    }, [mutation]);\n\n    const startWriting = useCallback(async () => {\n        await writeMutation.mutateAsync();\n    }, [writeMutation]);\n\n    const stop = useCallback(() => {\n        useGenerationStore.getState().stopGeneration();\n    }, []);\n\n    return { generate, startWriting, stop, status: mutation.status };\n};\n"],"names":[],"mappings":"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"}}]
}